# フィールド作成ツール設計書

## 1. クラス図

```mermaid
classDiagram
    %% 継承関係
    AbstractTool <|-- AbstractIoTool
    AbstractIoTool <|-- AbstractTwo2OneTool
    AbstractTwo2OneTool <|-- AbstractDtcTool
    AbstractDtcTool <|-- FieldCreationTool

    %% インターフェース実装関係
    IitoProcessorService <|.. FieldCreationService
    IctoOneLinePatternLogic <|.. FieldCreationLogic

    %% サービス実装関係
    AbstractIitoProcessorService ..|> IitoProcessorService
    FieldCreationServiceImpl --|> AbstractIitoProcessorService
    FieldCreationServiceImpl ..|> FieldCreationService
    FieldCreationLogicImpl --|> AbstractIctoOneLinePatternLogic
    FieldCreationLogicImpl ..|> FieldCreationLogic

    %% ロジック関係
    FieldCreationTool --> FieldCreationService : uses
    FieldCreationServiceImpl --> FieldCreationLogic : uses
    FieldCreationServiceImpl --> DtcService : uses

    %% テンプレート関連
    FieldCreationTool ..> FieldCreationTool.yml : uses template

    class AbstractTool {
        +boolean execute()
    }

    class AbstractIoTool {
        -String toolName
        +static Path getBasePath()
        +static Path getInputPath()
        +static Path getOutputPath()
        +boolean execute()
        #abstract IoService getIoService()
    }

    class AbstractTwo2OneTool {
        -Logger logger
        -Path templatePath
        +Path getTemplatePath()
        +boolean initialize()
        #abstract Two2OneService getIoService()
    }

    class AbstractDtcTool {
        +AbstractDtcTool(String toolName)
        #abstract IitoProcessorService getIoService()
    }

    class FieldCreationTool {
        -static String TOOL_NAME
        -FieldCreationService fieldCreationService
        +static void main(String[] args)
        +FieldCreationTool()
        #FieldCreationService getIoService()
    }

    class IitoProcessorService {
        <<interface>>
        +Path getInputPath()
        +Path getOutputPath()
        +Path getTemplatePath()
        +boolean initialize(Path inputPath, Path templatePath, Path outputPath)
        +boolean process()
    }

    class FieldCreationService {
        <<interface>>
    }

    class DtcService {
        <<interface>>
        +boolean initialize(Path inputPath, Path templatePath, Path outputPath)
        +boolean process()
    }

    class AbstractIitoProcessorService {
        -Path inputPath
        -Path templatePath
        -Path outputPath
        -Path intermediatePath
        -DtcService dtcService
        +Path getInputPath()
        +Path getOutputPath()
        +Path getTemplatePath()
        +Path getIntermediatePath()
        +boolean initialize(Path inputPath, Path templatePath, Path outputPath)
        +boolean process()
        #abstract boolean writeIntermediateFile()
    }

    class FieldCreationServiceImpl {
        -Logger logger
        -KmgMessageSource messageSource
        -FieldCreationLogic fieldCreationLogic
        +FieldCreationServiceImpl()
        #boolean writeIntermediateFile()
        -boolean processColumns()
        -boolean readOneLineData()
        -void writeIntermediateFileLine()
        -void clearAndPrepareNextLine()
        -void closeFieldCreationLogic()
    }

    class IctoOneLinePatternLogic {
        <<interface>>
        +boolean addRow(String value)
        +boolean clearRows()
        +boolean clearProcessingData()
        +boolean readOneLineOfData()
        +boolean writeIntermediateFile()
        +String getConvertedLine()
    }

    class FieldCreationLogic {
        <<interface>>
        +boolean addCommentToRows()
        +boolean addFieldToRows()
        +boolean addTypeToRows()
        +boolean convertFields()
        +String getComment()
        +String getField()
        +String getType()
    }

    class AbstractIctoOneLinePatternLogic {
        -Logger logger
        -KmgMessageSource messageSource
        -Path inputPath
        -Path outputPath
        -BufferedReader reader
        -BufferedWriter writer
        -String lineOfDataRead
        -String convertedLine
        -KmgDelimiterTypes outputDelimiter
        -int nowLineNumber
        -List~List~String~~ rows
        +boolean addRow(String value)
        +boolean clearRows()
        +boolean clearProcessingData()
        +boolean readOneLineOfData()
        +boolean writeIntermediateFile()
        +String getConvertedLine()
    }

    class FieldCreationLogicImpl {
        -String comment
        -String field
        -String type
        +boolean addCommentToRows()
        +boolean addFieldToRows()
        +boolean addTypeToRows()
        +boolean convertFields()
        +String getComment()
        +String getField()
        +String getType()
    }

    class FieldCreationTool.yml {
        intermediatePlaceholders
        templateContent
    }
```

## 2. シーケンス図

```mermaid
sequenceDiagram
    participant User as ユーザー
    participant FCT as FieldCreationTool
    participant ADT as AbstractDtcTool
    participant AT2OT as AbstractTwo2OneTool
    participant AIT as AbstractIoTool
    participant FCService as FieldCreationServiceImpl
    participant AIPS as AbstractIitoProcessorService
    participant FCLogic as FieldCreationLogicImpl
    participant DtcService as DtcService
    participant Template as FieldCreationTool.yml
    participant Input as input.txt
    participant Intermediate as 中間ファイル
    participant Output as output.txt

    User->>FCT: アプリケーション起動
    Note over FCT: main(String[] args)
    FCT->>FCT: SpringApplication.run
    FCT->>FCT: initialize()

    FCT->>AT2OT: initialize()
    AT2OT->>FCService: initialize(inputPath, templatePath, outputPath)
    FCService->>AIPS: initialize(inputPath, templatePath, outputPath)
    AIPS->>AIPS: createTemporaryIntermediateFile()

    FCT->>AIT: execute()
    AIT->>FCT: getIoService()
    FCT-->>AIT: fieldCreationService
    AIT->>FCService: process()
    FCService->>AIPS: process()
    AIPS->>FCService: writeIntermediateFile()

    FCService->>FCLogic: initialize(inputPath, intermediatePath)
    FCService->>FCLogic: addOneLineOfDataToRows()

    loop 入力ファイル処理
        FCService->>FCLogic: readOneLineOfData()
        FCLogic-->>Input: ファイル読み込み

        FCService->>FCService: processColumns()

        FCService->>FCLogic: convertFields()
        FCLogic->>FCLogic: フィールド定義解析処理
        Note over FCLogic: コメント、フィールド名、型情報を抽出<br/>フィールド名をキャメルケースに変換<br/>データ型をJava型に変換

        FCService->>FCLogic: addCommentToRows()
        FCLogic->>Intermediate: 中間ファイルにコメント追加

        FCService->>FCLogic: addFieldToRows()
        FCLogic->>Intermediate: 中間ファイルにフィールド名追加

        FCService->>FCLogic: addTypeToRows()
        FCLogic->>Intermediate: 中間ファイルに型情報追加

        FCService->>FCLogic: writeIntermediateFile()
        FCLogic->>Intermediate: 中間ファイル書き込み

        FCService->>FCService: clearAndPrepareNextLine()
        FCService->>FCLogic: clearRows()
        FCService->>FCLogic: clearProcessingData()
        FCService->>FCLogic: addOneLineOfDataToRows()
    end

    AIPS->>DtcService: initialize(intermediatePath, templatePath, outputPath)
    AIPS->>DtcService: process()
    DtcService->>Template: テンプレート読み込み
    DtcService->>Intermediate: 中間ファイル読み込み

    loop テンプレート適用処理
        DtcService->>DtcService: readOneLineData()
        DtcService->>DtcService: applyTemplateToInputFile()
        DtcService->>DtcService: addOutputBufferContent()
        DtcService->>DtcService: writeOutputBuffer()
        DtcService->>DtcService: clearOutputBufferContent()
    end

    DtcService->>Output: 出力ファイル生成

    FCService->>FCLogic: close()
    FCLogic->>FCLogic: closeReader()
    FCLogic->>FCLogic: closeWriter()

    FCT-->>User: 処理完了
```

## 3. テンプレートファイル構造

FieldCreationTool.yml は以下の構造を持っています：

1. **intermediatePlaceholders**: 中間ファイルから直接取得するプレースホルダー定義

   - displayName: 画面表示用の名称
   - replacementPattern: 置換対象のパターン

2. **templateContent**: テンプレートの内容
   - {comment}, {field}, {type}のプレースホルダーが実際の値に置換される

### intermediatePlaceholders

- 中間ファイルの各列から直接マッピングされるプレースホルダー
  - `{comment}`: フィールドのコメント
  - `{field}`: フィールド名（キャメルケース変換済み）
  - `{type}`: フィールドの型（Java 型に変換済み）

### templateContent

- Java フィールド定義のテンプレートを定義
- 上記のプレースホルダーを使用して、フィールドごとにカスタマイズされた Java フィールド定義を生成
- 各フィールドには Javadoc コメントも含まれる

## 4. 処理フロー詳細

1. ユーザーがアプリケーションを起動
2. SpringBoot アプリケーションが起動し、FieldCreationTool のインスタンスが生成される
3. AbstractTwo2OneTool の initialize()メソッドが呼び出され、FieldCreationService が初期化される
4. AbstractIoTool の execute()メソッドが呼び出され、メイン処理が実行される
5. FieldCreationServiceImpl の writeIntermediateFile()メソッドが実行され、入力ファイルの処理が開始される
6. 入力ファイルから 1 行ずつデータを読み込み、以下の処理を行う：
   - フィールド定義の解析（コメント、フィールド名、データ型の抽出）
   - フィールド名のキャメルケース変換
   - データベース型から Java 型への変換
   - 中間ファイル形式に変換して中間ファイルに書き込み
7. 中間ファイルの生成が完了したら、DtcService（テンプレートの動的変換サービス）を使用して：
   - テンプレートファイル（FieldCreationTool.yml）を読み込む
   - 中間ファイルのデータを読み込む
   - テンプレートにデータを適用して出力ファイルを生成する
8. リソースがクローズされ、処理が完了する

## 5. 主要コンポーネント

### FieldCreationTool

- SpringBootApplication として動作するエントリーポイント
- AbstractDtcTool を継承（さらに AbstractTwo2OneTool を継承）
- FieldCreationService を使用してフィールド生成を実行

### AbstractDtcTool

- AbstractTwo2OneTool を継承
- テンプレートの動的変換ツールの抽象クラス
- IitoProcessorService を返す抽象メソッドを定義

### AbstractTwo2OneTool

- AbstractIoTool を継承
- テンプレートファイルパスの管理と初期化処理を担当

### FieldCreationServiceImpl

- AbstractIitoProcessorService を継承
- FieldCreationService インターフェースを実装
- 入力ファイルの読み込みと中間ファイル形式への変換を担当

### FieldCreationLogicImpl

- AbstractIctoOneLinePatternLogic を継承
- FieldCreationLogic インターフェースを実装
- フィールド作成の実際のロジックを担当
- データベースフィールド定義から Java フィールド定義に必要な情報を抽出
- 中間ファイル形式の中間ファイルを生成

### DtcService（テンプレートの動的変換サービス）

- テンプレートファイルと中間ファイルデータを使用して最終的な出力ファイルを生成
- プレースホルダの置換処理を担当

### テンプレートファイル（FieldCreationTool.yml）

- YAML フォーマットで定義されたテンプレート設定ファイル
- 以下の主要セクションで構成：
  - `intermediatePlaceholders`: 中間ファイルから直接取得するプレースホルダー定義
  - `templateContent`: 実際のテンプレート内容

#### intermediatePlaceholders

- 中間ファイルの各列から直接マッピングされるプレースホルダー
  - `{comment}`: フィールドのコメント
  - `{field}`: フィールド名（キャメルケース変換済み）
  - `{type}`: フィールドの型（Java 型に変換済み）

#### templateContent

- Java フィールド定義のテンプレートを定義
- 上記のプレースホルダーを使用して、フィールドごとにカスタマイズされた Java フィールド定義を生成
- 各フィールドには Javadoc コメントも含まれる

## 6. 入力・出力仕様

### 入力ファイル仕様

入力ファイルは以下の形式でフィールド定義を記述します：

```
コメント フィールド名 データ型
```

例：

```
ユーザーID user_id VARCHAR
ユーザー名 user_name VARCHAR
作成日時 created_at TIMESTAMP
```

### 出力ファイル仕様

出力ファイルは以下の形式で Java フィールド定義が生成されます：

```java
/** ユーザーID */
private String userId;

/** ユーザー名 */
private String userName;

/** 作成日時 */
private Timestamp createdAt;
```

## 7. データ変換処理

### フィールド名変換

- データベースのフィールド名（スネークケース）を Java のフィールド名（キャメルケース）に変換
- 例：`user_id` → `userId`

### データ型変換

- データベースのデータ型を Java の型に変換
- 例：`VARCHAR` → `String`, `TIMESTAMP` → `Timestamp`

### パッケージ名除去

- 完全修飾名からパッケージ名を除去してクラス名のみを取得
- 例：`java.lang.String` → `String`
